
//Contexts
$con1 = {quantization=16,
		tempo=120,
		key=c#,
		octave_pos=4}

$con2 = {quantization=8}

//Chords
//A parallel expression can contain serial variables
// , and . can never be mixed in an expression
$chrd1 =  "1,3,5,6" in $con1
$chrd2 = "1,3,5,6" in $con1
$chrd3 = "c#+,e-,g#" in {octave_pos=4}

//alternative
$chrd1 =  1,3,5,6 {quantization = 4}
1,3,5,6 {quantization = 4}



//Input
//Mix of abs and rel input not allowed
//A serial expression can contain parallel variables
a = "Cm7....Cm7...Cm7/g...Cm7..."  {bars=4,signature=4/4,octave_pos=4}
b = "Ch1...2...3...4..." in $con1
c = "$chrd1...$chrd2..$chrd2." in $con1

//Patterns
funkify = n -> xx.x

$round = funkify C...G...Am...F $con?

//Transformations can only be done on music. Backend, create list of music instead of what you currently do.
$res = funkify $round
//$res = CC.CGG.GAmAm.AmFF.F
$a = funkify(C) 

modulate = n -> 2
add3rds = "n -> 1,3"
lick   = "n -> 12321"
3rdsTo4ths= "5 -> 1,3,5,7" 
time = "..-> ..."
time2 = ".->."

//Not equal patterns. sort patterns by strictness classes. If only one match from a class, use it. If more matches, use  randomness
//What if there is no pattern?
//If nothing else matches, identity exists with lowest priority
//How about adding constraints? Based on chord? 
$patterns= [modulate,add3rds,3rdsTo4ths]

$generated = random (len a) $patterns $con1
//this judgement, e, will have type derivations that allow sequential and parralel composiition so long that it consists of expressions of type music
$joined = "$a,generated"

$joined

"$b,generated"

//Applied Transformations

newTrack = modulate a

newTrack

a = newTrack

